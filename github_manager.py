# github_manager.py
import os
from github import Github, GithubException
from dotenv import load_dotenv

# Load environment variables from .env
load_dotenv()

class GitHubManager:
    """Manages GitHub repository creation, file commits, and GitHub Pages setup."""
    def __init__(self):
        # Retrieve credentials from environment
        self.token = os.getenv("GITHUB_TOKEN")
        self.username = os.getenv("GITHUB_USERNAME")
        if not self.token or not self.username:
            raise ValueError("GITHUB_TOKEN or GITHUB_USERNAME not set in .env")
        
        # Initialize the PyGithub client
        self.g = Github(self.token)
        self.user = self.g.get_user()
        
    def create_and_deploy(self, task_id: str, files: dict) -> tuple[str, str]:
        """
        Creates a new public repo, commits files, and enables GitHub Pages.
        
        Args:
            task_id: The unique task ID (used for the repo name).
            files: A dictionary of file names and their content (e.g., {"index.html": "<html>...", "README.md": "# App"}).
        
        Returns:
            A tuple (repo_url, pages_url)
        """
        repo_name = f"llm-app-{task_id}"
        
        # 1. Create New Public Repository
        try:
            print(f"Creating repository: {repo_name}...")
            repo = self.user.create_repo(
                name=repo_name,
                description=f"LLM-generated app for task: {task_id}",
                private=False,  # MUST be public
                has_issues=False,
                has_projects=False,
                has_wiki=False
            )
        except GithubException as e:
            # Handle case where repo already exists (useful for re-runs)
            if e.status == 422 and "already exists" in e.data['errors'][0]['message']:
                repo = self.user.get_repo(f"{self.username}/{repo_name}")
                print(f"Repository already exists. Using existing one: {repo.html_url}")
            else:
                raise e

        # 2. Add Standard Files (LICENSE and README.md)
        # Add MIT License
        files["LICENSE"] = self._generate_mit_license()
        # Ensure a professional README.md is present
        if "README.md" not in files:
             files["README.md"] = f"# {task_id} App\n\nGenerated by LLM Code Deployment Project.\n"

        # 3. Commit Files
        commit_sha = ""
        for file_name, content in files.items():
            try:
                # Use base64 encoding for content to handle binary/complex characters
                # NOTE: For simple text files like HTML, we don't strictly need base64, 
                # but it's safer for raw LLM output. PyGithub handles this for create_file.
                
                # Check if file exists to decide between create or update
                try:
                    contents = repo.get_contents(file_name)
                    # File exists, update it
                    update_commit = repo.update_file(contents.path, f"Update {file_name} for initial commit", content, contents.sha)
                    commit_sha = update_commit['commit'].sha
                except GithubException:
                    # File does not exist, create it
                    create_commit = repo.create_file(file_name, f"Initial commit of {file_name}", content)
                    commit_sha = create_commit['commit'].sha
                    
                print(f"Committed {file_name}. SHA: {commit_sha}")

            except Exception as e:
                print(f"Error committing {file_name}: {e}")
                raise e
        
        # 4. Enable GitHub Pages
        # Note: PyGithub Pages API has quirks. We'll use a direct source setting.
        pages_url = f"https://{self.username}.github.io/{repo_name}/"
        
        try:
            # Check if Pages is already enabled (for existing repos)
            repo.get_pages()
            print("GitHub Pages already enabled.")
        except GithubException as e:
            if e.status == 404:
                # Pages is NOT enabled, proceed to enable it.
                # Use the repository's main branch (usually 'main' or 'master')
                try:
                    # PyGithub method to set the source branch/path for Pages
                    repo.set_pages_source(
                        branch='main',
                        path='/'
                    )
                    print("Enabled GitHub Pages on 'main' branch, root path.")
                except Exception as inner_e:
                    # Catch potential errors if PyGithub's set_pages_source fails due to timing/state
                    print(f"Warning: Failed to enable Pages via set_pages_source. You may need to enable it manually. Error: {inner_e}")
            else:
                # Re-raise any other GitHub API error
                raise e

        # 5. Return Details
        # The Pages URL structure is predictable:
        return repo.html_url, commit_sha, pages_url

    def _generate_mit_license(self) -> str:
        """Generates a basic MIT License text."""
        year = '2025' # Current year
        return f"""
MIT License

Copyright (c) {year} {self.username}

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
"""

# --- Independent Test Block ---
if __name__ == "__main__":
    try:
        # **IMPORTANT:** Change this unique task ID every time you run the test!
        TEST_TASK_ID = "test-repo-001" 
        
        test_files = {
            "index.html": "<html><head><title>Test App</title></head><body><h1>Hello from LLM Code Deployment!</h1></body></html>",
            "README.md": f"# Test App\n\nThis is a test application for task {TEST_TASK_ID}."
        }

        manager = GitHubManager()
        repo_url, commit_sha, pages_url = manager.create_and_deploy(TEST_TASK_ID, test_files)
        
        print("\n--- TEST SUCCESSFUL ---")
        print(f"Repo URL: {repo_url}")
        print(f"Commit SHA: {commit_sha}")
        print(f"Pages URL (wait a minute to check): {pages_url}")

    except ValueError as e:
        print(f"Configuration Error: {e}. Please check your .env file.")
    except GithubException as e:
        print(f"GitHub API Error: {e.status} - {e.data['message']}. Check your GITHUB_TOKEN scopes.")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")